document.body.style.margin = 0;
document.body.style.overflow = `hidden`;

const cnv = document.getElementById(`cnv_element`);
cnv.width = cnv.parentNode.scrollWidth;
cnv.height = (cnv.width * 9) / 16;
cnv.style.backgroundColor = `hotpink`;

const ctx = cnv.getContext(`2d`);

let ImgData;
// Declaring a let variable to store the image's unspecified/undefined blob of data.

const draw = (i) => ctx.drawImage(i, 0, 0, cnv.width, cnv.height);
// Draws an existing image onto the canvas.

const img = new Image();
// Creates a new imag object. The class for this image object
// is stored in the Javascript DOM API.

img.onload = () => {
  console.log(`Image loaded`); // Logs when the image is loaded.

  cnv.height = (cnv.width * img.height) / img.width;
  // Adjust the height of the canvas to maintain the aspect ratio of the image.

  draw(img);
  // Draws image onto the canvas.

  ImgData = cnv.toDataURL(`image/jpeg`);
  // Stores and transform the data into a based64 encoded string specifically in
  // the jpeg format.

  add_glitch();
  // Calls the function to add glitch effects to the image.
};
img.src = `./img/LannyGlasses.JPG`;
// Get the (hopefully) correct source of the image. (The path)

const RandInt = (max) => Math.floor(Math.random() * max);

const Glitchify = (ImgData, chunk_max, repeats) => {
  const ChunkSize = RandInt(chunk_max / 4) * 4;
  const i = RandInt(ImgData.length - 24 - ChunkSize, ImgData.length) + 24;
  const front = ImgData.slice(0, i);
  const back = ImgData.slice(i + ChunkSize, ImgData.length);
  const result = front + back;
  return repeats == 0 ? result : Glitchify(result, chunk_max, repeats - 1);
};
// Glitchify functions functionally removes chunks of the base64 encoded data,
// this leads visual dstortion of the image.

const glitch_arr = [];

const add_glitch = () => {
  if (!ImgData) {
    console.error("ImgData is not set. Cannot create glitch.");
    return;
  }

  const img = new Image();
  img.onload = () => {
    glitch_arr.push(img);
    if (glitch_arr.length < 12) add_glitch();
    else draw_frame();
  };
  img.src = Glitchify(ImgData, 96, 6);
};
// Stores up to 12 different glitched versions of the images generated by
// the glitchify function. The images are stored in the array called glitch_arr.

let is_glitching = false;
let glitch_i = 0;

const draw_frame = (ms) => {
  if (is_glitching) draw(glitch_arr[glitch_i]);
  else draw(img);

  const prob = is_glitching ? 0.05 : 0.02;
  if (Math.random() < prob) {
    glitch_i = RandInt(glitch_arr.length);
    is_glitching = !is_glitching;
  }
  requestAnimationFrame(draw_frame);
};
// Does the flickering between the distored version of the image
// and the original image.
// The flickering is done by using a random number generator to determine

draw_frame();

onresize = () => {
  cnv.width = innerWidth;
  cnv.height = innerHeight;
  draw(img);
};
