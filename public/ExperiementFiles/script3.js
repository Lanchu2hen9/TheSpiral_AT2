document.body.style.margin = 0;
document.body.style.overflow = `hidden`;

const cnv = document.getElementById(`cnv_element`);
cnv.width = cnv.parentNode.scrollWidth;
cnv.height = (cnv.width * 9) / 16;
cnv.style.backgroundColor = `hotpink`;

const ctx = cnv.getContext(`2d`);

let ImgData;
// Declaring a let variable to store the image's unspecified/undefined blob of data.

const draw = (i) => ctx.drawImage(i, 0, 0, cnv.width, cnv.height);
// Draws an existing image onto the canvas.

const img = new Image();
// Creates a new imag object. The class for this image object
// is stored in the Javascript DOM API.

img.onload = () => {
  console.log(`Image loaded`); // Logs when the image is loaded.

  cnv.height = (cnv.width * img.height) / img.width;
  // Adjust the height of the canvas to maintain the aspect ratio of the image.

  draw(img);
  // Draws image onto the canvas.

  ImgData = cnv.toDataURL(`image/jpeg`);
  // Stores and transform the data into a based64 encoded string specifically in
  // the jpeg format.

  add_glitch();
  // Calls the function to add glitch effects to the image.
};
img.src = `./img/LannyGlasses.JPG`;
// Get the (hopefully) correct source of the image. (The path)

//img.src = `./img/LannyGlasses.JPG`;

const RandInt = (max) => Math.floor(Math.random() * max);
//tl;dr, RandInt is the randomiser.

// Returns random integer => Rounds down to nearest whole no.((â‰ˆ)* max)
// max is a random ass number that makes sure that the value  outputted by the
// Maths.random() is large enough to be rounded down into a whole number.

// Everytime you call the RandInt arrow function you are essientally "redefining"
// the max value.

// If the max is removed:
// Maths.floor(Maths.random()) ==> Maths.random() ==> Outputs a value that is [0, 1),
// for example 0.4 ==> Maths.floor(), then rounds 0.4 down ==> result will always be 0.

const Glitchify = (ImgData, chunk_max, repeats) => {
  const ChunkSize = RandInt(chunk_max / 4) * 4;
  // Declares the const variable ChunkSize, and determines the size of the removed chunks
  // based on the RandInt.
  // The number generated by this line of code will always be divisble by 4. This is
  // because of the "*4" which always makes the number a multiple of 4.
  // Also determines how much of the image data you want to glitch.

  const i = RandInt(ImgData.length - 24 - ChunkSize, ImgData.length) + 24;
  // Go the 24th position of the base64 encoded string, select a chunk of data,
  // which is randomised by the RandInt function, to glitchify. Then add 24 to the
  // glitched chunk of data.

  // The 24 is there because the first 24 characters of the base64 encoded string is
  // metadata of the image. And if you remove it, the browser will commit suicide and
  // not display the image.

  // The above function also determines the "index"/position in which you want to slice
  // things in the future.

  const front = ImgData.slice(0, i);
  // Declares variable front = and then cuts the data from the start of the base64 blob
  // of data to the "i" value/index value as defined on the previous line.

  const back = ImgData.slice(i + ChunkSize, ImgData.length);
  // Does the same thing as the previous line of code, but you're slicing the ImgData
  // blob from the ass end of it.

  const result = front + back;
  // Result = the head and the ass added together.

  return repeats == 0 ? result : Glitchify(result, chunk_max, repeats - 1);
  // If the value of repeats is exactly equals to 0, then stop the glitchify function,
  // if not then continue the Glitchify value.
  // See line 116.
};
// Glitchify functions functionally removes chunks of the base64 encoded data,
// this leads visual dstortion of the image.

const glitch_arr = [];
// Empty array to store the glitched images.

const add_glitch = () => {
  if (!ImgData) {
    console.error("ImgData is not set. Cannot create glitch.");
    return;
  }
  // Logs the ImgData if the image is not available to be set.

  const img = new Image();
  // Creates a new Image Object.

  img.onload = () => {
    glitch_arr.push(img);
    // Pushes the glitched images into the glitch_arr image.

    if (glitch_arr.length < 12) add_glitch();
    // if the number of the glitched images in the array is
    // less than 12. Then add glitch if not,
    else draw_frame();
    // Then start the animation.
  };

  //img.src = Glitchify(ImgData, 96, 26);
  img.src = Glitchify(ImgData, 96, 7);

  // img.src =
  // Glitchify(ImgData, the maximum ChunkSize of the image
  // that you want to be glitched, The inital amount of repeats);
};
// Stores up to 12 different glitched versions of the images generated by
// the glitchify function. The images are stored in the array called glitch_arr.

let is_glitching = false;
// Boolean variable to see if the image is glitching or not.

let glitch_i = 0;
// Index for the glitch_arr.

const draw_frame = (ms) => {
  if (is_glitching) draw(glitch_arr[glitch_i]);
  // If the image is glitching, then draw it glitching.
  else draw(img);
  // If not glitching, draw the original image.

  //const prob = is_glitching ? 0.1 : 0.05;
  const prob = is_glitching ? 0.05 : 0.02;
  // Probability of the image glitching.

  if (Math.random() < prob) {
    //If the a value of [0, 1) is less than 0.05 or 0.02,
    glitch_i = RandInt(glitch_arr.length);
    // then choose a random glitched image from the 'glitch_arr',

    is_glitching = !is_glitching;
    // and then it turns/toggles the glitching effect on/off.
  }
  requestAnimationFrame(draw_frame);
};
// Does the flickering between the distored version of the image
// and the original image.
// The flickering is done by using a random number generator to determine

draw_frame();

onresize = () => {
  cnv.width = innerWidth;
  cnv.height = innerHeight;
  draw(img);
};
