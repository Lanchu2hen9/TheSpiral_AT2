import SimplexNoise from "https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/dist/esm/simplex-noise.js";

// import { run } from "./AT2-V1.0.js";

const simplex = new SimplexNoise();
// AT2-V1.0.js
function run(simplex) {
  console.log(simplex.noise2D(0.1, 0.2)); // you can now use it here!

  document.body.style.margin = "0";
  document.body.style.overflow = "hidden";

  const cnv = document.getElementById("cnv_element");
  cnv.width = innerWidth;
  cnv.height = innerHeight;

  const ctx = cnv.getContext("2d");

  const noise = new SimplexNoise();
  let stars = [];
  // Creates an array to store the Star objects.

  let IsClicked = false;
  let StarBrightness = 170;
  let FlickerSize = 2;

  function random(arg1, arg2) {
    // Defines two arguments array parameters
    //  within the function random.

    if (arguments.length == 1) {
      // If the the length of the arguments array
      // is equals roughly to 1.

      const max = arg1;
      // Then define max as arg1.

      return Math.random() * max;
      // Stops the function from executing
      // and gives a random number
      // between 0 and max.
    } else if (arguments.length == 2) {
      // If the length of the arguments arrays
      // is roughly equal to 2.

      const min = arg1;
      // Define min as arg1.

      const max = arg2;
      // Define max as arg2.

      const range = max - min;
      // Define range as max - min.

      return Math.random() * range + min;
      // Stops the function from executing,
      // and outputs a random number.
    }
  }
  // In general, this is the randomiser function
  // that randomises values inputted into it.

  class Star {
    constructor(x, y, BaseSize, speed, zoff, r, g, b) {
      this.x = random(innerWidth);
      this.y = random(innerHeight);
      // (this.x, this.y) are the "centre point",
      // of the star.

      this.BaseSize = random(1.5, 9);
      // Determines the size of the star, from
      // size 1 start to size 8 star.

      this.speed = random(1, 2.5);
      // Determines the speed of the star moving left
      // across the screen.

      this.zoff = random(1000);
      // Determines how fast the noise field animates across the
      // screen.

      // Higher values, the slower the flickering of the stars is
      // slower.

      // Lower values, the faster the flickering of the stars is.
    }
    // Constructor function, that defines
    // the instance variables of the Star object.

    show() {
      ctx.save();
      // Save the current state of the shape.

      ctx.translate(this.x, this.y);
      // translate the shape, by this.x
      // and this.y as defined in the constructor.

      this.zoff += 0.01;
      // Animates how fast the stars flicker.

      const NoiseEffect = noise.noise2D(this.x * 0.01, this.zoff);
      // Generates a noise value outputted by the .noise2D();
      //  NoiseEffect is a noise field that outputs [-1, 1].

      const TransformedSize = this.BaseSize + NoiseEffect * FlickerSize;
      // Transformed the BaseSize of the star, based on the NoiseEffect
      // generated by the Simplex Noise field.

      this.r = Math.floor(noise.noise2D(this.zoff, 0) * StarBrightness + 250);
      // Generates a random red value, based on the noise field.

      // For the red channel value
      // Round down the generated noise value to the nearest integer.
      // Step 1. Input zoff value in .nosee2D() function, this is how
      // the star flickers animates over time.
      // Step 2. Multiply the generated noise value by 127, this
      // converts the noise value to a range of [-127, 127].
      // Step 3. [-127 + 128, 127 + 128], which gives [1, 255]

      this.g = Math.floor(
        noise.noise2D(this.zoff + 100, 0) * StarBrightness + 250
      );
      // Generates a random green value, based on the noise field.

      this.b = Math.floor(
        noise.noise2D(this.zoff + 200, 0) * StarBrightness + 250
      );
      // Generates a random blue value, based on the noise field.

      ctx.beginPath();
      // Start drawing the shape.

      const arms = 8;
      // The star shape has 8 arms.

      for (let i = 0; i < arms; i++) {
        // Count from 0 to arms, where
        // arms the max number of arms
        // the star can have.

        const angle = ((Math.PI * 2) / arms) * i;
        // The angle between each of the arms,
        // is 2ฯ รท no. of arms.

        const x = Math.cos(angle) * TransformedSize;
        // Start drawing the star at x-coordinate,
        // which is cos(angle) * size of the Star.

        const y = Math.sin(angle) * TransformedSize;
        // Start drawing the star at x-coordinate,
        // which is cos(angle) * size of the Star.

        ctx.moveTo(0, 0);
        // Move the drawing cursor to the "centre" of the star.

        ctx.lineTo(x, y);
        // Draws each arm of the Star.
      }

      ctx.strokeStyle = `rgb(${this.r}, ${this.g}, ${this.b})`;
      // Make the lines drawn be white.

      ctx.lineWidth = 1;
      // The thicccness of the lines drawn is 1.
      ctx.stroke();
      // Defines the colour of the lines drawn.

      ctx.restore();
      // Restores the start state of the shape.
      // So basically, it spews out another Star,
      // for the update() function to move.
    }

    update() {
      this.x -= this.speed;
      // Moves the Star.

      // Resets the Star positions when they go off screen.
      if (this.x < -this.BaseSize) {
        // If the centre of the star is less than the right-
        // side of the Star, then the star is off screen.

        this.x = innerWidth + this.BaseSize;
        // Then yeet it to the right side of the screen.

        this.y = random(innerHeight);
        // Places Star on a random position on the y-axis,
        // of the canvas.
      }
    }
  }
  // This is the Star object.

  function OnUserClick() {
    cnv.addEventListener("mousedown", () => {
      IsClicked = true;
      StarBrightness = 360;
      FlickerSize = 370;

      setTimeout(() => {
        IsClicked = false;
        StarBrightness = 170;
        FlickerSize = 2;
      }, 1700);
    });

    // Within this instance method, we want to have it
    // so that when the user clicks the this.r, this.g, this.b
    // changes/brightens. Specifically, the "170" value.\

    // We also want either fractual trees or "lightning" to shoot
    // of the point in which the user clicks, so we might need to use
    //mouseX and mouseY to get the coordinates of the mouse click.
  }

  function setup() {
    for (let i = 0; i < 100; i++) {
      // For one star every time, i interates from
      // 0 to 100.

      stars.push(new Star());
      // Push the created Star objects into the stars array.
    }
    OnUserClick();

    requestAnimationFrame(draw_frame);
    // Calls the draw_frame function.
  }

  const draw_frame = (ms) => {
    ctx.fillStyle = "black";
    // Set the background colour to black.

    ctx.fillRect(0, 0, innerWidth, innerHeight);
    // Fills the entire canvas with black. And resizes the canvas to be
    // the same size as the window.

    const seconds = ms / 1000;
    // Converts the milliseconds to seconds.

    //   console.log(seconds.toFixed(2));

    for (let i = 0; i < stars.length; i++) {
      // For every star in the stars array.

      stars[i].show();
      // Draw the stars.

      stars[i].update();
      // Move the stars's position.
    }

    requestAnimationFrame(draw_frame);
  };

  setup();

  requestAnimationFrame(draw_frame);

  // draw_frame();

  onresize = () => {
    cnv.width = innerWidth;
    cnv.height = innerHeight;
  };
}

run(simplex);
