import SimplexNoise from "https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/dist/esm/simplex-noise.js";

// import { run } from "./AT2-V1.0.js";

const simplex = new SimplexNoise();

const noise = new SimplexNoise();
let stars = [];
// Creates an array to store the Star objects.

let Zeus = [];
// Creates an array to store the ThunderStrikes objects.

let IsClicked = false;
// Defining a boolean variable, to check if the
// user has clicked on the canvas.

let StarBrightness = 170;
// Variable that defines the default brightness
// of the stars.

let FlickerSize = 2;
// Variable that defines the default flicker size.

const cnv = document.getElementById("cnv_element");
cnv.width = innerWidth;
cnv.height = innerHeight;

const ctx = cnv.getContext("2d");

// AT2-V1.0.js
function run(simplex) {
  console.log(simplex.noise2D(0.1, 0.2)); // you can now use it here!

  document.body.style.margin = "0";
  document.body.style.overflow = "hidden";
  setup();
}

//#region Objects:

//#region Star Object
class Star {
  constructor(x, y, BaseSize, speed, zoff, r, g, b) {
    this.x = Random(innerWidth);
    this.y = Random(innerHeight);
    // (this.x, this.y) are the "centre point",
    // of the star.

    this.BaseSize = Random(1.5, 9);
    // Determines the size of the star, from
    // size 1 start to size 8 star.

    this.speed = Random(1, 2.5);
    // Determines the speed of the star moving left
    // across the screen.

    this.zoff = Random(1000);
    // Determines how fast the noise field animates across the
    // screen.

    // Higher values, the slower the flickering of the stars is
    // slower.

    // Lower values, the faster the flickering of the stars is.
  }
  // Constructor function, that defines
  // the instance variables of the Star object.

  show() {
    ctx.save();
    // Save the current state of the shape.

    ctx.translate(this.x, this.y);
    // translate the shape, by this.x
    // and this.y as defined in the constructor.

    this.zoff += 0.01;
    // Animates how fast the stars flicker.

    const NoiseEffect = noise.noise2D(this.x * 0.01, this.zoff);
    // Generates a noise value outputted by the .noise2D();
    //  NoiseEffect is a noise field that outputs [-1, 1].

    const TransformedSize = this.BaseSize + NoiseEffect * FlickerSize;
    // Transformed the BaseSize of the star, based on the NoiseEffect
    // generated by the Simplex Noise field.

    this.r = Math.floor(noise.noise2D(this.zoff, 0) * StarBrightness + 250);
    // Generates a random red value, based on the noise field.

    // For the red channel value
    // Round down the generated noise value to the nearest integer.
    // Step 1. Input zoff value in .nosee2D() function, this is how
    // the star flickers animates over time.
    // Step 2. Multiply the generated noise value by 127, this
    // converts the noise value to a range of [-127, 127].
    // Step 3. [-127 + 128, 127 + 128], which gives [1, 255]

    this.g = Math.floor(
      noise.noise2D(this.zoff + 100, 0) * StarBrightness + 250
    );
    // Generates a random green value, based on the noise field.

    this.b = Math.floor(
      noise.noise2D(this.zoff + 200, 0) * StarBrightness + 250
    );
    // Generates a random blue value, based on the noise field.

    ctx.beginPath();
    // Start drawing the shape.

    const arms = 8;
    // The star shape has 8 arms.

    for (let i = 0; i < arms; i++) {
      // Count from 0 to arms, where
      // arms the max number of arms
      // the star can have.

      const angle = ((Math.PI * 2) / arms) * i;
      // The angle between each of the arms,
      // is 2ฯ รท no. of arms.

      const x = Math.cos(angle) * TransformedSize;
      // Start drawing the star at x-coordinate,
      // which is cos(angle) * size of the Star.

      const y = Math.sin(angle) * TransformedSize;
      // Start drawing the star at x-coordinate,
      // which is cos(angle) * size of the Star.

      ctx.moveTo(0, 0);
      // Move the drawing cursor to the "centre" of the star.

      ctx.lineTo(x, y);
      // Draws each arm of the Star.
    }

    ctx.globalAlpha = 1;
    ctx.strokeStyle = `rgb(${this.r}, ${this.g}, ${this.b})`;
    // Make the lines drawn be white.

    ctx.lineWidth = 1;
    // The thicccness of the lines drawn is 1.
    ctx.stroke();
    // Defines the colour of the lines drawn.

    ctx.restore();
    // Restores the start state of the shape.
    // So basically, it spews out another Star,
    // for the update() function to move.
  }

  update() {
    this.x -= this.speed;
    // Moves the Star.

    // Resets the Star positions when they go off screen.
    if (this.x < -this.BaseSize) {
      // If the centre of the star is less than the right-
      // side of the Star, then the star is off screen.

      this.x = innerWidth + this.BaseSize;
      // Then yeet it to the right side of the screen.

      this.y = Random(innerHeight);
      // Places Star on a random position on the y-axis,
      // of the canvas.
    }
  }
}
// This is the Star object.
//#endregion

//#region Lightning Object
class LigthningStrikes {
  constructor(x, y, length, depth, alphas) {
    this.x = x;
    this.y = y;
    this.length = length;

    this.depth = depth;

    this.angle = Math.random() * Math.PI * 2;
    // Chooses a random angle for the lightning strike.

    this.alphas = 1;
    // The transparency of the lightning strike.

    this.child = null;

    this.createChild();
  }

  createChild() {
    if (this.length > 10 && this.depth < 4) {
      const NewX = this.x + Math.cos(this.angle) * this.length;
      const NewY = this.y + Math.sin(this.angle) * this.length;
      this.child = new LigthningStrikes(
        NewX,
        NewY,
        this.length * 0.6,
        this.depth + 1
      );
    }
  }
  update() {
    this.alphas -= 0.02;

    if (this.child) this.child.update();
  }
  draw(ctx) {
    if (this.alphas <= 0) return;

    ctx.globalAlpha = this.alphas;

    ctx.strokeStyle = `rgba(255, 255, ${this.alphas})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    const EndX = this.x + Math.cos(this.angle) * this.length;
    const EndY = this.y + Math.sin(this.angle) * this.length;
    ctx.lineTo(EndX, EndY);
    ctx.stroke();

    if (this.child) this.child.draw(ctx);

    ctx.globalAlpha = 1;
  }
  isDead() {
    return this.alphas <= 0;
  }
}
// requestAnimationFrame(draw_frame);
//#endregion

// #endregions

//#region Setup Function
function setup() {
  OnUserClick();
  for (let i = 0; i < 100; i++) {
    // For one star every time, i interates from
    // 0 to 100.

    stars.push(new Star());
    // Push the created Star objects into the stars array.
  }
  requestAnimationFrame(draw_frame);
  // Calls the draw_frame function.
}

//#region Random Function
function Random(arg1, arg2) {
  // Defines two arguments array parameters
  //  within the function random.

  if (arguments.length == 1) {
    // If the the length of the arguments array
    // is equals roughly to 1.

    const max = arg1;
    // Then define max as arg1.

    return Math.random() * max;
    // Stops the function from executing
    // and gives a random number
    // between 0 and max.
  } else if (arguments.length == 2) {
    // If the length of the arguments arrays
    // is roughly equal to 2.

    const min = arg1;
    // Define min as arg1.

    const max = arg2;
    // Define max as arg2.

    const range = max - min;
    // Define range as max - min.

    return Math.random() * range + min;
    // Stops the function from executing,
    // and outputs a random number.
  }
}
// In general, this is the randomiser function
// that randomises values inputted into it.
//#endregion
//#endregion

//#region Draw Function
const draw_frame = (ms) => {
  ctx.fillStyle = "black";
  // Set the background colour to black.

  ctx.fillRect(0, 0, innerWidth, innerHeight);
  // Fills the entire canvas with black. And resizes the canvas to be
  // the same size as the window.

  const seconds = ms / 1000;
  // Converts the milliseconds to seconds.

  //   console.log(seconds.toFixed(2));

  for (let i = 0; i < stars.length; i++) {
    // For every star in the stars array.

    stars[i].show();
    // Draw the stars.

    stars[i].update();
    // Move the stars's position.
  }

  requestAnimationFrame(draw_frame);
};

//#region LightningYeeter Function:
function LightningYeeter() {
  requestAnimationFrame(() => LightningYeeter(ctx));
  ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
  ctx.fillRect(0, 0, innerWidth, innerHeight);

  for (let i = Zeus.length - 1; i >= 0; i--) {
    Zeus[i].update();
    Zeus[i].draw(ctx);
    if (Zeus[i].isDead()) Zeus.splice(i, 1);
  }
}

//#region OnUserClick Function
function OnUserClick() {
  cnv.addEventListener("mousedown", (e) => {
    const x = e.clientX;
    const y = e.clientY;

    IsClicked = true;
    StarBrightness = 360;
    FlickerSize = 370;

    for (let i = 0; i < 20; i++) {
      Zeus.push(new LigthningStrikes(x, y, 100, 0));
    }

    LightningYeeter();

    setTimeout(() => {
      IsClicked = false;
      StarBrightness = 170;
      FlickerSize = 2;
    }, 1700);
  });

  // Within this instance method, we want to have it
  // so that when the user clicks the this.r, this.g, this.b
  // changes/brightens. Specifically, the "170" value.\

  // We also want either fractual trees or "lightning" to shoot
  // of the point in which the user clicks, so we might need to use
  //mouseX and mouseY to get the coordinates of the mouse click.
}
//#endregion
//#endregion

onresize = () => {
  cnv.width = innerWidth;
  cnv.height = innerHeight;
};

run(simplex);
